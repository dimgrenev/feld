var ee = Object.defineProperty;
var te = (o, e, t) => e in o ? ee(o, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[e] = t;
var a = (o, e, t) => te(o, typeof e != "symbol" ? e + "" : e, t);
import * as j from "react";
class ne {
  constructor() {
    a(this, "events", /* @__PURE__ */ new Map());
  }
  emit(e, t) {
    const n = this.events.get(e);
    n && n.forEach((r) => {
      try {
        r(t);
      } catch (s) {
        console.error(`Error in event callback for ${e}:`, s);
      }
    });
  }
  on(e, t) {
    this.events.has(e) || this.events.set(e, []), this.events.get(e).push(t);
  }
  off(e, t) {
    const n = this.events.get(e);
    if (n) {
      const r = n.indexOf(t);
      r > -1 && n.splice(r, 1), n.length === 0 && this.events.delete(e);
    }
  }
  once(e, t) {
    const n = (r) => {
      t(r), this.off(e, n);
    };
    this.on(e, n);
  }
  clear() {
    this.events.clear();
  }
  getEventCount(e) {
    var t;
    return ((t = this.events.get(e)) == null ? void 0 : t.length) || 0;
  }
  getAllEvents() {
    return Array.from(this.events.keys());
  }
}
const R = new ne();
class re {
  constructor() {
    a(this, "hooks", /* @__PURE__ */ new Map());
    a(this, "errorCallbacks", []);
  }
  onBeforeRegister(e) {
    this.addHook("beforeRegister", e);
  }
  onAfterRegister(e) {
    this.addHook("afterRegister", e);
  }
  onBeforeRender(e) {
    this.addHook("beforeRender", e);
  }
  onAfterRender(e) {
    this.addHook("afterRender", e);
  }
  onError(e) {
    this.errorCallbacks.push(e);
  }
  async executeLifecycle(e, t) {
    const n = this.hooks.get(e) || [];
    for (const r of n)
      try {
        await r(t);
      } catch (s) {
        console.error(`Error in lifecycle hook ${e}:`, s), await this.handleError(s, t);
      }
    R.emit(`lifecycle:${e}`, t);
  }
  async handleError(e, t) {
    for (const n of this.errorCallbacks)
      try {
        await n(e, t);
      } catch (r) {
        console.error("Error in error callback:", r);
      }
    R.emit("lifecycle:error", { error: e, context: t });
  }
  addHook(e, t) {
    this.hooks.has(e) || this.hooks.set(e, []), this.hooks.get(e).push(t);
  }
  getHookCount(e) {
    var t;
    return ((t = this.hooks.get(e)) == null ? void 0 : t.length) || 0;
  }
  clearHooks(e) {
    e ? this.hooks.delete(e) : this.hooks.clear();
  }
  clearErrorCallbacks() {
    this.errorCallbacks = [];
  }
}
const g = new re();
class k {
  constructor(e, t, n, r, s, i, l) {
    a(this, "componentStore");
    a(this, "dataService");
    a(this, "pluginManager");
    a(this, "validator");
    a(this, "errorHandler");
    a(this, "testRunner");
    a(this, "logger");
    this.componentStore = e, this.dataService = t, this.pluginManager = n, this.validator = r, this.errorHandler = s, this.testRunner = i, this.logger = l, this.logger.info("Engine initialized");
  }
  // === КОМПОНЕНТЫ ===
  async registerComponent(e, t, n) {
    try {
      await g.executeLifecycle("beforeRegister", { name: e, component: t, schema: n }), this.componentStore.registerComponent(e, t, n), await g.executeLifecycle("afterRegister", { name: e, component: t, schema: n }), this.logger.info(`Component registered: ${e}`);
    } catch (r) {
      await this.handleError(r, { operation: "registerComponent", name: e });
    }
  }
  getComponent(e) {
    return this.componentStore.getComponent(e);
  }
  getComponentSchema(e) {
    return this.componentStore.getComponentSchema(e);
  }
  // === РЕНДЕРИНГ ===
  async render(e, t) {
    try {
      if (await g.executeLifecycle("beforeRender", { userFace: e, adapterId: t }), !this.componentStore.getComponent(e.component))
        throw new Error(`Component not found: ${e.component}`);
      if (e.data)
        for (const [s, i] of Object.entries(e.data)) {
          const l = await this.dataService.getData(i.source, i.config);
          e[s] = l;
        }
      const r = {
        component: e.component,
        props: e,
        adapterId: t,
        timestamp: Date.now()
      };
      return await g.executeLifecycle("afterRender", { userFace: e, adapterId: t, result: r }), r;
    } catch (n) {
      return await this.handleError(n, { operation: "render", userFace: e, adapterId: t });
    }
  }
  // === DATA SERVICE ===
  registerDataSource(e, t) {
    this.dataService.registerDataSource(e, t);
  }
  async getData(e, t) {
    return this.dataService.getData(e, t);
  }
  subscribeToData(e, t) {
    return this.dataService.subscribe(e, t);
  }
  getDataState(e) {
    return this.dataService.getState(e);
  }
  // === АДАПТЕРЫ ===
  registerAdapter(e) {
    var t, n;
    (n = (t = this.componentStore).registerAdapter) == null || n.call(t, e), this.logger.info(`Adapter registered: ${e.id || e.name}`);
  }
  getAdapter(e) {
    var t, n;
    return (n = (t = this.componentStore).getAdapter) == null ? void 0 : n.call(t, e);
  }
  getAllAdapters() {
    var e, t;
    return ((t = (e = this.componentStore).getAllAdapters) == null ? void 0 : t.call(e)) || [];
  }
  // === ПЛАГИНЫ ===
  async registerPlugin(e, t) {
    await this.pluginManager.registerPlugin(e, t);
  }
  async installPlugin(e) {
    await this.pluginManager.installPlugin(e);
  }
  async uninstallPlugin(e) {
    await this.pluginManager.uninstallPlugin(e);
  }
  getActivePlugins() {
    return this.pluginManager.getActivePlugins();
  }
  getInstalledPlugins() {
    return this.pluginManager.getInstalledPlugins();
  }
  getEnabledPlugins() {
    return this.pluginManager.getEnabledPlugins();
  }
  getPlugin(e) {
    return this.pluginManager.getPlugin(e);
  }
  getAllPlugins() {
    return this.pluginManager.getAllPlugins();
  }
  // === ТЕСТИРОВАНИЕ ===
  async runAllTests() {
    return this.testRunner.runAllTests();
  }
  createMockComponent(e, t, n) {
    return this.testRunner.createMockComponent(e, t, n);
  }
  // === ЖИЗНЕННЫЙ ЦИКЛ ===
  onBeforeRegister(e) {
    g.onBeforeRegister(e);
  }
  onAfterRegister(e) {
    g.onAfterRegister(e);
  }
  onBeforeRender(e) {
    g.onBeforeRender(e);
  }
  onAfterRender(e) {
    g.onAfterRender(e);
  }
  onError(e) {
    g.onError(e);
  }
  // === СОБЫТИЯ ===
  on(e, t) {
    R.on(e, t);
  }
  off(e, t) {
    R.off(e, t);
  }
  emit(e, t) {
    R.emit(e, t);
  }
  // === ПРИВАТНЫЕ МЕТОДЫ ===
  async handleError(e, t) {
    this.logger.error(`Engine error: ${e.message}`, t);
    try {
      console.error("Engine error:", e.message, t);
    } catch (n) {
      this.logger.error("Error handling failed:", n);
    }
    throw e;
  }
  // === СТАТИСТИКА ===
  getStats() {
    return {
      components: this.componentStore.getAllComponents().size,
      plugins: this.pluginManager.getAllPlugins().length,
      activePlugins: this.pluginManager.getActivePlugins().length,
      dataSources: this.dataService.getDataStats().totalSources,
      testResults: this.testRunner.getTestResults().length
    };
  }
}
class N {
  constructor() {
    a(this, "components", /* @__PURE__ */ new Map());
    a(this, "schemas", /* @__PURE__ */ new Map());
    // === АДАПТЕРЫ ===
    a(this, "adapters", /* @__PURE__ */ new Map());
  }
  registerComponent(e, t, n) {
    try {
      n || (n = {
        name: e,
        platform: "universal",
        props: [],
        events: []
      }), this.components.set(e, t), this.schemas.set(e, n), console.log(`Component registered: ${e}`, { schema: n.name });
    } catch (r) {
      throw console.error(`Failed to register component: ${e}`, r), r;
    }
  }
  getComponent(e) {
    const t = this.components.get(e);
    return t || (console.warn(`Component not found: ${e}`), null);
  }
  getComponentSchema(e) {
    const t = this.schemas.get(e);
    return t || (console.warn(`Schema not found for component: ${e}`), null);
  }
  getAllComponents() {
    return new Map(this.components);
  }
  getAllSchemas() {
    return new Map(this.schemas);
  }
  removeComponent(e) {
    this.components.get(e) ? (this.components.delete(e), this.schemas.delete(e), console.log(`Component removed: ${e}`)) : console.warn(`Component not found for removal: ${e}`);
  }
  clear() {
    const e = this.components.size;
    this.components.clear(), this.schemas.clear(), console.log(`Registry cleared, removed ${e} components`);
  }
  // === ДОПОЛНИТЕЛЬНЫЕ МЕТОДЫ ===
  hasComponent(e) {
    return this.components.has(e);
  }
  getComponentCount() {
    return this.components.size;
  }
  getComponentNames() {
    return Array.from(this.components.keys());
  }
  updateComponentSchema(e, t) {
    this.components.has(e) ? (this.schemas.set(e, t), console.log(`Schema updated for component: ${e}`)) : console.warn(`Cannot update schema for non-existent component: ${e}`);
  }
  validateComponent(e) {
    const t = this.components.get(e), n = this.schemas.get(e);
    return !t || !n ? !1 : typeof t == "function" || typeof t == "object";
  }
  registerAdapter(e) {
    const t = e.id || `adapter-${this.adapters.size}`;
    this.adapters.set(t, e), console.log(`Adapter registered: ${t}`);
  }
  getAdapter(e) {
    return this.adapters.get(e);
  }
  getAllAdapters() {
    return Array.from(this.adapters.values());
  }
}
class se {
  constructor() {
    a(this, "logs", []);
    a(this, "maxLogs", 1e3);
    a(this, "logLevel", "info");
  }
  // По умолчанию
  setLogLevel(e) {
    this.logLevel = e;
  }
  shouldLog(e) {
    const t = ["debug", "info", "warn", "error"], n = t.indexOf(this.logLevel);
    return t.indexOf(e) >= n;
  }
  addLog(e) {
    this.logs.push(e), this.logs.length > this.maxLogs && (this.logs = this.logs.slice(-this.maxLogs));
    {
      const t = `[${e.context || "UserFace"}]`;
      switch (e.level) {
        case "debug":
          console.debug(`${t} ${e.message}`, e.data);
          break;
        case "info":
          console.info(`${t} ${e.message}`, e.data);
          break;
        case "warn":
          console.warn(`${t} ${e.message}`, e.data);
          break;
        case "error":
          console.error(`${t} ${e.message}`, e.error || e.data);
          break;
      }
    }
  }
  debug(e, t, n) {
    this.shouldLog("debug") && this.addLog({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: "debug",
      message: e,
      context: t,
      data: n
    });
  }
  info(e, t, n) {
    this.shouldLog("info") && this.addLog({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: "info",
      message: e,
      context: t,
      data: n
    });
  }
  warn(e, t, n) {
    this.shouldLog("warn") && this.addLog({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: "warn",
      message: e,
      context: t,
      data: n
    });
  }
  error(e, t, n, r) {
    this.shouldLog("error") && this.addLog({
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level: "error",
      message: e,
      context: t,
      data: r,
      error: n
    });
  }
  // Получение логов
  getLogs(e) {
    return e ? this.logs.filter((t) => t.level === e) : [...this.logs];
  }
  // Очистка логов
  clear() {
    this.logs = [];
  }
  // Экспорт логов
  export() {
    return [...this.logs];
  }
}
const c = new se();
class B {
  constructor() {
    a(this, "dataSources", /* @__PURE__ */ new Map());
    a(this, "dataStates", /* @__PURE__ */ new Map());
    a(this, "subscriptions", /* @__PURE__ */ new Map());
    a(this, "cache", /* @__PURE__ */ new Map());
    a(this, "apiClient");
    a(this, "stateManager");
    a(this, "reactivityEngine");
    a(this, "dataValidator");
    this.apiClient = this.createAPIClient(), this.stateManager = this.createStateManager(), this.reactivityEngine = this.createReactivityEngine(), this.dataValidator = this.createDataValidator(), c.debug("DataLayer initialized");
  }
  registerDataSource(e, t) {
    this.dataSources.set(e, t), c.debug(`Data source registered: ${e} (type: ${t.type})`);
  }
  unregisterDataSource(e) {
    this.dataSources.delete(e), this.dataStates.delete(e), this.clearCache(e), c.debug(`Data source unregistered: ${e}`);
  }
  async getData(e, t) {
    const n = this.dataSources.get(e);
    if (!n)
      throw new Error(`Data source not found: ${e}`);
    const r = { ...n, ...t };
    if (r.cache) {
      const s = this.getFromCache(e);
      if (s)
        return s;
    }
    try {
      let s;
      switch (r.type) {
        case "api":
          s = await this.fetchFromAPI(e, r);
          break;
        case "local":
          s = await this.getFromLocal(e, r);
          break;
        case "websocket":
          s = await this.getFromWebSocket(e, r);
          break;
        case "file":
          s = await this.getFromFile(e, r);
          break;
        default:
          throw new Error(`Unsupported data source type: ${r.type}`);
      }
      return r.transform && (s = r.transform(s)), r.cache && this.setCache(e, s, 3e5), this.updateDataState(e, {
        loading: !1,
        data: s,
        lastUpdated: Date.now(),
        error: null,
        source: n.type
      }), this.notifySubscribers(e, s), s;
    } catch (s) {
      const i = s instanceof Error ? s.message : String(s);
      throw this.updateDataState(e, {
        loading: !1,
        error: i,
        data: null,
        lastUpdated: Date.now(),
        source: n.type
      }), c.error(`Failed to get data: ${e} - ${s instanceof Error ? s.message : String(s)}`), s;
    }
  }
  subscribe(e, t) {
    const n = `${e}-${Date.now()}-${Math.random()}`, r = {
      id: n,
      path: e,
      callback: t,
      active: !0
    };
    return this.subscriptions.has(e) || this.subscriptions.set(e, []), this.subscriptions.get(e).push(r), c.debug(`Subscription created: ${n} for ${e}`), r;
  }
  unsubscribe(e) {
    for (const [t, n] of this.subscriptions.entries()) {
      const r = n.findIndex((s) => s.id === e);
      if (r !== -1) {
        n.splice(r, 1), n.length === 0 && this.subscriptions.delete(t), c.debug(`Subscription removed: ${e}`);
        break;
      }
    }
  }
  getFromCache(e) {
    const t = this.cache.get(e);
    return t && Date.now() - t.timestamp < t.ttl ? t.data : (t && this.cache.delete(e), null);
  }
  setCache(e, t, n) {
    this.cache.set(e, {
      data: t,
      timestamp: Date.now(),
      ttl: n
    });
  }
  clearCache(e) {
    e ? this.cache.delete(e) : this.cache.clear();
  }
  createAPIClient() {
    return {
      get: async (e) => {
        const t = await fetch(e);
        if (!t.ok)
          throw new Error(`HTTP ${t.status}: ${t.statusText}`);
        return t.json();
      },
      post: async (e, t) => {
        const n = await fetch(e, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(t)
        });
        if (!n.ok)
          throw new Error(`HTTP ${n.status}: ${n.statusText}`);
        return n.json();
      },
      put: async (e, t) => {
        const n = await fetch(e, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(t)
        });
        if (!n.ok)
          throw new Error(`HTTP ${n.status}: ${n.statusText}`);
        return n.json();
      },
      delete: async (e) => {
        const t = await fetch(e, { method: "DELETE" });
        if (!t.ok)
          throw new Error(`HTTP ${t.status}: ${t.statusText}`);
        return t.json();
      }
    };
  }
  createStateManager() {
    return {
      getState: (e) => this.dataStates.get(e),
      setState: (e, t) => {
        const r = { ...this.dataStates.get(e) || {
          loading: !1,
          error: null,
          data: null,
          lastUpdated: Date.now(),
          source: "api"
        }, ...t };
        this.dataStates.set(e, r);
      },
      getAllStates: () => new Map(this.dataStates)
    };
  }
  createReactivityEngine() {
    return {
      subscribe: (e, t) => {
        const n = `${e}-reactive-${Date.now()}`;
        return this.subscribe(e, t), n;
      },
      unsubscribe: (e) => this.unsubscribe(e),
      notify: (e, t) => this.notifySubscribers(e, t)
    };
  }
  createDataValidator() {
    return {
      validate: (e) => e != null,
      sanitize: (e) => e
    };
  }
  async fetchFromAPI(e, t) {
    if (!t.url)
      throw new Error("URL is required for API data source");
    return this.apiClient.get(t.url);
  }
  async getFromLocal(e, t) {
    return {};
  }
  async getFromWebSocket(e, t) {
    return {};
  }
  async getFromFile(e, t) {
    return {};
  }
  updateDataState(e, t) {
    const r = { ...this.dataStates.get(e) || {
      loading: !1,
      error: null,
      data: null,
      lastUpdated: Date.now(),
      source: "api"
    }, ...t };
    this.dataStates.set(e, r);
  }
  notifySubscribers(e, t) {
    const n = this.subscriptions.get(e);
    if (n) {
      const r = this.dataStates.get(e);
      n.forEach((s) => {
        if (s.active)
          try {
            s.callback(t, r || {
              loading: !1,
              error: null,
              data: null,
              lastUpdated: Date.now(),
              source: "api"
            });
          } catch (i) {
            c.error(`Error in subscription callback: ${s.id} - ${i instanceof Error ? i.message : String(i)}`);
          }
      });
    }
  }
  getState(e) {
    return this.dataStates.get(e);
  }
  getAllStates() {
    return new Map(this.dataStates);
  }
  clearAllData() {
    this.dataStates.clear(), this.cache.clear(), this.subscriptions.clear();
  }
  getStats() {
    return {
      dataSources: this.dataSources.size,
      states: this.dataStates.size,
      subscriptions: Array.from(this.subscriptions.values()).flat().length,
      cache: this.cache.size
    };
  }
  // === МЕТОДЫ ИНТЕРФЕЙСА IDataLayer ===
  subscribeToData(e, t) {
    return this.subscribe(e, t);
  }
  getDataState(e) {
    return this.getState(e);
  }
  getDataStats() {
    return this.getStats();
  }
  async renderWithData(e, t) {
    const n = e.component, r = e.data || {};
    return {
      component: n,
      data: r,
      adapterId: t,
      timestamp: Date.now()
    };
  }
}
const d = new B();
class T {
  constructor(e) {
    a(this, "plugins", /* @__PURE__ */ new Map());
    a(this, "configs", /* @__PURE__ */ new Map());
    a(this, "statuses", /* @__PURE__ */ new Map());
    this.registry = e;
  }
  async registerPlugin(e, t) {
    c.info(`Plugin "${e.name}" registered (id: ${e.id}, type: ${e.type})`), this.plugins.set(e.id, e), this.configs.set(e.id, {
      enabled: !1,
      priority: 0,
      settings: {},
      ...t
    }), this.statuses.set(e.id, {
      id: e.id,
      installed: !1,
      enabled: !1,
      version: e.version
    });
  }
  async installPlugin(e) {
    const t = this.plugins.get(e);
    if (!t) throw new Error(`Plugin not found: ${e}`);
    t.install && await t.install();
    const n = this.statuses.get(e);
    n && (n.installed = !0), c.info(`Plugin "${t.name}" installed (id: ${e})`);
  }
  async uninstallPlugin(e) {
    const t = this.plugins.get(e);
    if (!t) throw new Error(`Plugin not found: ${e}`);
    t.uninstall && await t.uninstall();
    const n = this.statuses.get(e);
    n && (n.installed = !1, n.enabled = !1), c.info(`Plugin "${t.name}" uninstalled (id: ${e})`);
  }
  async enablePlugin(e) {
    const t = this.plugins.get(e);
    if (!t) throw new Error(`Plugin not found: ${e}`);
    t.enable && await t.enable();
    const n = this.statuses.get(e);
    n && (n.enabled = !0);
    const r = this.configs.get(e);
    r && (r.enabled = !0), c.info(`Plugin "${t.name}" enabled (id: ${e})`);
  }
  async disablePlugin(e) {
    const t = this.plugins.get(e);
    if (!t) throw new Error(`Plugin not found: ${e}`);
    t.disable && await t.disable();
    const n = this.statuses.get(e);
    n && (n.enabled = !1);
    const r = this.configs.get(e);
    r && (r.enabled = !1), c.info(`Plugin "${t.name}" disabled (id: ${e})`);
  }
  getPlugin(e) {
    return this.plugins.get(e);
  }
  getAllPlugins() {
    return Array.from(this.plugins.values());
  }
  getPluginsByType(e) {
    return Array.from(this.plugins.values()).filter((t) => t.type === e);
  }
  getActivePlugins() {
    return Array.from(this.plugins.values()).filter((e) => {
      const t = this.statuses.get(e.id);
      return t == null ? void 0 : t.installed;
    });
  }
  getInstalledPlugins() {
    return Array.from(this.plugins.values()).filter((e) => {
      const t = this.statuses.get(e.id);
      return t == null ? void 0 : t.installed;
    });
  }
  getEnabledPlugins() {
    return Array.from(this.plugins.values()).filter((e) => {
      const t = this.statuses.get(e.id);
      return t == null ? void 0 : t.enabled;
    });
  }
  getPluginStatus(e) {
    return this.statuses.get(e);
  }
  getAllStatuses() {
    return Array.from(this.statuses.values());
  }
  updatePluginConfig(e, t) {
    const n = this.configs.get(e);
    n && Object.assign(n, t);
  }
  async removePlugin(e) {
    await this.uninstallPlugin(e), this.plugins.delete(e), this.configs.delete(e), this.statuses.delete(e), c.info(`Plugin removed (id: ${e})`);
  }
  async clear() {
    for (const e of this.plugins.keys())
      await this.removePlugin(e);
  }
}
let f;
function ae(o) {
  return f = new T(o), f;
}
class M extends Error {
  constructor(e, t, n, r) {
    super(e), this.code = t, this.details = n, this.face = r, this.name = "UserFaceError";
  }
}
class v extends M {
  constructor(e) {
    super(
      `Component "${e}" not found`,
      "COMPONENT_NOT_FOUND",
      `Component "${e}" is not registered in the registry`
    );
  }
}
class L extends M {
  constructor(e, t, n) {
    super(e, "VALIDATION_ERROR", t, n);
  }
}
class Me extends M {
  constructor(e, t, n) {
    super(e, "RENDER_ERROR", t, n);
  }
}
class oe extends Error {
  constructor(t, n, r, s) {
    super(t);
    a(this, "field");
    a(this, "value");
    a(this, "rule");
    this.name = "ValidationWarning", this.field = n, this.value = r, this.rule = s;
  }
}
class W {
  validateUserFace(e, t) {
    c.debug(`Validating UserFace: ${e.component} with schema: ${t.name}`);
    const n = [], r = [], s = this.validateProps(e, t);
    n.push(...s.errors), r.push(...s.warnings);
    const i = this.validateEvents(e, t);
    return n.push(...i.errors), r.push(...i.warnings), {
      isValid: n.length === 0,
      errors: n,
      warnings: r
    };
  }
  validateProps(e, t) {
    const n = [], r = [];
    for (const s of t.props) {
      const i = e[s.name];
      if (s.required && i == null) {
        n.push(new L(
          `Required prop '${s.name}' is missing`,
          s.name,
          i
        ));
        continue;
      }
      if (i != null) {
        const l = this.validatePropValue(i, s);
        l.isValid || n.push(new L(
          l.message,
          s.name,
          i
        ));
      }
    }
    return { isValid: n.length === 0, errors: n, warnings: r };
  }
  validateEvents(e, t) {
    const n = [], r = [];
    if (e.events)
      for (const s in e.events)
        t.events.find((l) => l.name === s) || r.push(new oe(
          `Unknown event '${s}'`,
          s,
          e.events[s],
          { field: s, type: "custom" }
        ));
    return { isValid: n.length === 0, errors: n, warnings: r };
  }
  validatePropValue(e, t) {
    if (!this.validateType(e, t.type))
      return {
        isValid: !1,
        message: `Expected type '${t.type}', got '${typeof e}'`
      };
    if (t.validation && Array.isArray(t.validation)) {
      for (const n of t.validation)
        if (!this.validateRule(e, n))
          return {
            isValid: !1,
            message: n.message || `Validation failed for '${t.name}'`
          };
    }
    return { isValid: !0, message: "" };
  }
  validateType(e, t) {
    switch (t) {
      case "text":
        return typeof e == "string";
      case "number":
        return typeof e == "number" && !isNaN(e);
      case "boolean":
        return typeof e == "boolean";
      case "function":
        return typeof e == "function";
      case "object":
        return typeof e == "object" && e !== null;
      case "array":
        return Array.isArray(e);
      default:
        return !0;
    }
  }
  validateRule(e, t) {
    switch (t.type) {
      case "required":
        return e != null && e !== "";
      case "min":
        return typeof e == "number" && e >= (t.value || 0);
      case "max":
        return typeof e == "number" && e <= (t.value || 1 / 0);
      case "pattern":
        return typeof e == "string" && new RegExp(t.value || "").test(e);
      case "custom":
        return t.validator ? t.validator(e) : !0;
      default:
        return !0;
    }
  }
}
const $ = new W();
class _ {
  constructor() {
    a(this, "defaultFallback", "div");
  }
  handleComponentError(e, t, n) {
    const r = n || this.getDefaultConfig();
    switch (c.warn(`Component error occurred: ${t.component} - ${e.message} (strategy: ${r.strategy})`), r.strategy) {
      case "fallback":
        return this.createFallbackComponent(e, t, r.fallbackComponent);
      case "retry":
        return this.retryComponent(t, r);
      case "ignore":
        return this.createSilentFallback(t);
      case "throw":
      default:
        throw e;
    }
  }
  createFallbackComponent(e, t, n) {
    return {
      component: n || this.defaultFallback,
      props: {
        style: {
          padding: "10px",
          border: "1px solid #ff6b6b",
          backgroundColor: "#ffe6e6",
          color: "#d63031",
          borderRadius: "4px",
          fontSize: "14px"
        },
        children: this.formatErrorMessage(e, t)
      },
      error: e,
      originalSpec: t
    };
  }
  createSilentFallback(e) {
    return {
      component: this.defaultFallback,
      props: {
        style: { display: "none" },
        children: null
      },
      originalSpec: e
    };
  }
  retryComponent(e, t) {
    const n = t.maxRetries || 3;
    return c.info(`Retrying component: ${e.component} (max retries: ${n})`), this.createFallbackComponent(
      new Error(`Component failed after ${n} retries`),
      e,
      t.fallbackComponent
    );
  }
  formatErrorMessage(e, t) {
    return `Error rendering component '${t.component}': ${e.message}`;
  }
  canRecover(e) {
    return ![
      "Component not found",
      "Invalid component definition",
      "Critical system error"
    ].some((n) => e.message.includes(n));
  }
  getRecommendedStrategy(e) {
    return this.canRecover(e) ? e.message.includes("Network") || e.message.includes("Timeout") ? "retry" : "fallback" : "throw";
  }
  getDefaultConfig() {
    return {
      strategy: "fallback",
      maxRetries: 3,
      fallbackComponent: this.defaultFallback,
      logErrors: !0
    };
  }
}
const V = new _();
class J {
  constructor() {
    a(this, "testSuites", []);
    a(this, "results", []);
    a(this, "environment");
    a(this, "mockComponents", /* @__PURE__ */ new Map());
  }
  async runTest(e, t) {
    const n = Date.now();
    let r = !1, s;
    try {
      await t(), r = !0;
    } catch (h) {
      s = h instanceof Error ? h.message : String(h);
    }
    const i = Date.now() - n, l = { name: e, passed: r, error: s, duration: i };
    return this.results.push(l), l;
  }
  async runTestSuite(e, t) {
    c.info(`Running test suite: ${e}`);
    const n = [];
    for (const r of t) {
      const s = await this.runTest(r.name, r.test);
      n.push(s);
    }
    return n;
  }
  createMockComponent(e, t, n) {
    const r = {
      name: e,
      schema: t,
      render: n || ((s) => ({ type: "div", props: s }))
    };
    return this.mockComponents.set(e, r), r;
  }
  getMockComponent(e) {
    return this.mockComponents.get(e);
  }
  getAllMockComponents() {
    return Array.from(this.mockComponents.values());
  }
  generateTestData(e) {
    const t = {
      component: e.name
    };
    for (const n of e.props)
      switch (n.type) {
        case "text":
          t[n.name] = `Test ${n.name}`;
          break;
        case "number":
          t[n.name] = 42;
          break;
        case "boolean":
          t[n.name] = !0;
          break;
        case "array":
          t[n.name] = [];
          break;
        case "object":
          t[n.name] = {};
          break;
        default:
          t[n.name] = null;
      }
    return t;
  }
  getTestResults() {
    return [...this.results];
  }
  clearTestResults() {
    this.results = [];
  }
  getTestSummary() {
    const e = this.results.length, t = this.results.filter((s) => s.passed).length, n = e - t, r = this.results.reduce((s, i) => s + i.duration, 0);
    return { total: e, passed: t, failed: n, duration: r };
  }
  // === НОВЫЕ МЕТОДЫ ИЗ .D.TS ===
  addTestSuite(e) {
    this.testSuites.push(e);
  }
  createTestCase(e, t, n) {
    return {
      name: e,
      test: t,
      ...n
    };
  }
  async runAllTests() {
    const e = [];
    for (const t of this.testSuites) {
      const n = await this.runTestSuite(t.name, t.tests);
      e.push(...n);
    }
    return e;
  }
  generateRandomUserFace(e) {
    return this.generateTestData(e);
  }
  mockComponent(e, t, n) {
    this.createMockComponent(e, t, n);
  }
}
const K = new J();
class ie {
  static createEngine() {
    const e = new N(), t = d, n = new T(e), r = $, s = V, i = K, l = c;
    return new k(
      e,
      t,
      n,
      r,
      s,
      i,
      l
    );
  }
  static createEngineWithCustomServices(e, t, n, r, s, i, l) {
    return new k(
      e,
      t,
      n,
      r,
      s,
      i,
      l
    );
  }
}
const m = ie.createEngine();
class ce {
  info(e, t, n) {
    console.log(`[INFO] ${t ? `[${t}]` : ""} ${e}`, n || "");
  }
  warn(e, t, n) {
    console.warn(`[WARN] ${t ? `[${t}]` : ""} ${e}`, n || "");
  }
  error(e, t, n) {
    console.error(`[ERROR] ${t ? `[${t}]` : ""} ${e}`, n || "");
  }
  debug(e, t, n) {
    console.debug(`[DEBUG] ${t ? `[${t}]` : ""} ${e}`, n || "");
  }
}
class le extends k {
  constructor() {
    const e = new ce(), t = new N(), n = new B(), r = new T(t), s = new W(), i = new _(), l = new J();
    super(
      t,
      n,
      r,
      s,
      i,
      l,
      e
    );
  }
  // Переопределяем методы которые требуют браузерные API
  async render(e, t) {
    try {
      if (!this.getComponent(e.component))
        throw new Error(`Component not found: ${e.component}`);
      return {
        component: e.component,
        props: e,
        adapterId: t,
        timestamp: Date.now(),
        environment: "node"
      };
    } catch (n) {
      return console.error("Render error:", n), { error: n.message, environment: "node" };
    }
  }
}
const Ve = new le();
let u = null, P = null, b = null, A = null, x = null, D = null;
if (typeof window < "u" && window.React)
  u = window.React, P = u.createContext, b = u.useState, A = u.useEffect, x = u.useContext, D = u.useMemo;
else if (typeof require < "u")
  try {
    u = require("react"), P = u.createContext, b = u.useState, A = u.useEffect, x = u.useContext, D = u.useMemo;
  } catch {
    console.warn("React not available in Node.js environment");
  }
class ue {
  createElement(e, t, n) {
    return u.createElement(e, t, ...n);
  }
  render(e, t) {
    typeof window < "u" && window.ReactDOM && window.ReactDOM.render(e, t);
  }
  unmount(e) {
    typeof window < "u" && window.ReactDOM && window.ReactDOM.unmountComponentAtNode(e);
  }
}
const F = P(null);
class Fe {
  constructor() {
    a(this, "face", null);
    a(this, "options", {});
    a(this, "contextValue", null);
  }
  initialize(e, t) {
    this.face = e, this.options = t || {};
  }
  getData() {
    return this.contextValue;
  }
  updateData(e) {
    this.contextValue = e;
  }
  cleanup() {
    this.face = null, this.contextValue = null;
  }
  getContext() {
    return F;
  }
  createProvider(e) {
    if (!this.face)
      throw new Error("Context not initialized");
    return u.createElement(de, {
      face: this.face,
      children: e,
      ...this.options
    });
  }
}
const de = ({
  face: o,
  children: e,
  remoteBundles: t = [],
  registryKey: n = "userRegistry",
  onReady: r,
  onError: s,
  fallback: i
}) => {
  const [l, h] = b(!1), [p, y] = b(null), G = D(() => t.join(","), [t]), Y = () => {
    h(!1), y(null), U();
  }, U = async () => {
    if (t.length === 0) {
      h(!0), r == null || r();
      return;
    }
    try {
      window[n] = {};
      const C = t.map((w) => new Promise((X, Z) => {
        const S = document.createElement("script");
        S.src = `${w}?t=${(/* @__PURE__ */ new Date()).getTime()}`, S.async = !0, S.onload = () => {
          console.log(`[RenderReact] Loaded remote bundle: ${w}`), X();
        }, S.onerror = () => {
          console.error(`[RenderReact] Failed to load remote bundle: ${w}`), Z(new Error(`Failed to load: ${w}`));
        }, document.head.appendChild(S);
      }));
      await Promise.all(C), h(!0), r == null || r();
    } catch (C) {
      const w = C instanceof Error ? C.message : String(C);
      y(w), s == null || s(w);
    }
  };
  A(() => {
    U();
  }, [G]);
  const Q = {
    face: o,
    isReady: l,
    error: p,
    reload: Y
  };
  return p ? u.createElement("div", {
    style: {
      padding: "20px",
      border: "1px solid #ff6b6b",
      backgroundColor: "#ffe6e6",
      color: "#d63031",
      borderRadius: "4px"
    }
  }, `Error: ${p}`) : l ? u.createElement(F.Provider, { value: Q }, e) : i ? u.createElement(u.Fragment, {}, i) : null;
}, me = () => {
  const o = x(F);
  if (!o)
    throw new Error("useUserContext must be used within a UserContextProvider");
  return o;
}, Ue = () => me().face, je = ({
  face: o,
  fallback: e,
  onError: t
}) => {
  const [n, r] = b(null), [s, i] = b(null);
  if (A(() => {
    (async () => {
      try {
        const y = (window.userRegistry || {})[o.component];
        if (!y)
          throw new v(o.component);
        i(() => y), r(null);
      } catch (p) {
        const y = p instanceof Error ? p.message : String(p);
        r(y), t == null || t(y, o);
      }
    })();
  }, [o.component, t]), n)
    return u.createElement("div", {
      style: {
        padding: "10px",
        border: "1px solid #ff6b6b",
        backgroundColor: "#ffe6e6",
        color: "#d63031",
        borderRadius: "4px"
      }
    }, `Error: ${n}`);
  if (!s)
    return e ? u.createElement(e) : null;
  const l = { ...o };
  return delete l.component, delete l.data, u.createElement(s, l);
};
class he {
  constructor() {
    a(this, "id", "react");
    a(this, "meta", {
      name: "React Renderer",
      version: "1.0.0",
      platform: "react"
    });
    a(this, "renderer", new ue());
  }
  render(e) {
    try {
      if (!this.validateSpec(e))
        throw new Error("Invalid UserFace specification");
      const t = this.getComponentFromRegistry(e.component);
      if (!t)
        throw new v(e.component);
      const n = this.adaptProps(e);
      return this.validateUniversalTypes(n), u.createElement(t, n);
    } catch (t) {
      throw c.error(`React render failed: ${t.message}`, "RenderReact", { spec: e, error: t }), t;
    }
  }
  isCompatible(e) {
    return u.isValidElement(e) || typeof e == "function" || e.$$typeof === u.elementType;
  }
  getSupportedComponents() {
    return ["div", "span", "button", "input", "form", "img", "a", "p", "h1", "h2", "h3", "h4", "h5", "h6"];
  }
  validateSpec(e) {
    return e && typeof e.component == "string" && e.component.length > 0;
  }
  getComponentFromRegistry(e) {
    return m.getComponent(e);
  }
  adaptProps(e) {
    const t = {};
    for (const [n, r] of Object.entries(e))
      if (!(n === "component" || n === "data"))
        if (n.startsWith("on") && typeof r == "function") {
          const s = this.mapEventName(n);
          s && (t[s] = r);
        } else
          t[n] = r;
    return t;
  }
  validateUniversalTypes(e) {
    for (const [t, n] of Object.entries(e))
      if (t !== "children" && n != null) {
        const r = typeof n;
        ["string", "number", "boolean", "function", "object"].includes(r) || c.warn(`Unsupported prop type: ${r} for ${t}`, "RenderReact");
      }
  }
  validateType(e, t) {
    switch (t) {
      case "text":
        return typeof e == "string";
      case "number":
        return typeof e == "number" && !isNaN(e);
      case "boolean":
        return typeof e == "boolean";
      case "function":
        return typeof e == "function";
      case "object":
        return typeof e == "object" && e !== null;
      case "array":
        return Array.isArray(e);
      default:
        return !0;
    }
  }
  mapEventName(e) {
    return {
      onClick: "onClick",
      onChange: "onChange",
      onSubmit: "onSubmit",
      onFocus: "onFocus",
      onBlur: "onBlur",
      onKeyDown: "onKeyDown",
      onKeyUp: "onKeyUp",
      onMouseEnter: "onMouseEnter",
      onMouseLeave: "onMouseLeave"
    }[e] || null;
  }
}
const z = new he();
class ge {
  createElement(e, t, n) {
    return {
      type: e,
      props: t,
      children: n
    };
  }
  render(e, t) {
    console.log("[VueRenderer] Rendering component:", e);
  }
  unmount(e) {
    console.log("[VueRenderer] Unmounting component from container:", e);
  }
}
class fe {
  constructor() {
    a(this, "id", "vue");
    a(this, "meta", {
      name: "Vue Adapter",
      version: "1.0.0",
      platform: "vue"
    });
    a(this, "renderer", new ge());
    // Компоненты, которые поддерживает этот адаптер
    a(this, "supportedComponents", [
      "button",
      "text",
      "input",
      "card",
      "modal",
      "form",
      "list",
      "table",
      "tabs",
      "accordion",
      "slider",
      "progress",
      "checkbox",
      "radio",
      "select",
      "textarea",
      "image",
      "link",
      "container",
      "layout",
      "media",
      "panel",
      "side",
      "footer",
      "filter",
      "feed",
      "code",
      "cardcart",
      "article"
    ]);
  }
  // Рендеринг компонента
  render(e) {
    const { component: t, ...n } = e, r = this.getComponentFromRegistry(t);
    if (!r)
      throw new v(t);
    const s = this.adaptProps(n);
    return this.renderer.createElement(r, s, []);
  }
  // Проверка совместимости компонента
  isCompatible(e) {
    return !!(e && (e.render || e.template || e.setup));
  }
  // Получение поддерживаемых компонентов
  getSupportedComponents() {
    return this.supportedComponents;
  }
  // Валидация спецификации
  validateSpec(e) {
    if (!e.component || typeof e.component != "string" || !m.getComponent(e.component))
      return !1;
    const n = m.getComponentSchema(e.component);
    if (n) {
      const r = n.props.filter((s) => s.required);
      for (const s of r)
        if (e[s.name] === void 0)
          return !1;
    }
    return !0;
  }
  // Адаптация пропсов для Vue
  adaptProps(e) {
    const t = {};
    return e.text !== void 0 && (t.text = e.text), e.number !== void 0 && (t.number = e.number), e.boolean !== void 0 && (t.boolean = e.boolean), e.array !== void 0 && (t.array = e.array), e.object !== void 0 && (t.object = e.object), e.function !== void 0 && (t.function = e.function), e.element !== void 0 && (t.element = e.element), e.color !== void 0 && (t.color = e.color), e.dimension !== void 0 && (t.dimension = e.dimension), e.resource !== void 0 && (t.resource = e.resource), e.meta && (e.meta.className && (t.class = e.meta.className), e.meta.style && (t.style = e.meta.style), e.meta.theme && (t.theme = e.meta.theme)), e.events && Object.keys(e.events).forEach((n) => {
      t[`on${n.charAt(0).toUpperCase() + n.slice(1)}`] = e.events[n];
    }), Object.keys(e).forEach((n) => {
      ["text", "number", "boolean", "array", "object", "function", "element", "color", "dimension", "resource", "meta", "events"].includes(n) || (t[n] = e[n]);
    }), t;
  }
  // Получение компонента из реестра
  getComponentFromRegistry(e) {
    return m.getComponent(e);
  }
}
const O = new fe();
class pe {
  createElement(e, t, n) {
    return {
      type: e,
      props: t,
      children: n
    };
  }
  render(e, t) {
    console.log("[AngularRenderer] Rendering component:", e);
  }
  unmount(e) {
    console.log("[AngularRenderer] Unmounting component from container:", e);
  }
}
class ye {
  constructor() {
    a(this, "id", "angular");
    a(this, "meta", {
      name: "Angular Adapter",
      version: "1.0.0",
      platform: "angular"
    });
    a(this, "renderer", new pe());
    // Компоненты, которые поддерживает этот адаптер
    a(this, "supportedComponents", [
      "button",
      "text",
      "input",
      "card",
      "modal",
      "form",
      "list",
      "table",
      "tabs",
      "accordion",
      "slider",
      "progress",
      "checkbox",
      "radio",
      "select",
      "textarea",
      "image",
      "link",
      "container",
      "layout",
      "media",
      "panel",
      "side",
      "footer",
      "filter",
      "feed",
      "code",
      "cardcart",
      "article"
    ]);
  }
  // Рендеринг компонента
  render(e) {
    const { component: t, ...n } = e, r = this.getComponentFromRegistry(t);
    if (!r)
      throw new v(t);
    const s = this.adaptProps(n);
    return this.renderer.createElement(r, s, []);
  }
  // Проверка совместимости компонента
  isCompatible(e) {
    return !!(e && (e.selector || e.templateUrl || e.template));
  }
  // Получение поддерживаемых компонентов
  getSupportedComponents() {
    return this.supportedComponents;
  }
  // Валидация спецификации
  validateSpec(e) {
    if (!e.component || typeof e.component != "string" || !m.getComponent(e.component))
      return !1;
    const n = m.getComponentSchema(e.component);
    if (n) {
      const r = n.props.filter((s) => s.required);
      for (const s of r)
        if (e[s.name] === void 0)
          return !1;
    }
    return !0;
  }
  // Адаптация пропсов для Angular
  adaptProps(e) {
    const t = {};
    return e.text !== void 0 && (t.text = e.text), e.number !== void 0 && (t.number = e.number), e.boolean !== void 0 && (t.boolean = e.boolean), e.array !== void 0 && (t.array = e.array), e.object !== void 0 && (t.object = e.object), e.function !== void 0 && (t.function = e.function), e.element !== void 0 && (t.element = e.element), e.color !== void 0 && (t.color = e.color), e.dimension !== void 0 && (t.dimension = e.dimension), e.resource !== void 0 && (t.resource = e.resource), e.meta && (e.meta.className && (t.className = e.meta.className), e.meta.style && (t.style = e.meta.style), e.meta.theme && (t.theme = e.meta.theme)), e.events && Object.keys(e.events).forEach((n) => {
      t[n] = e.events[n];
    }), Object.keys(e).forEach((n) => {
      ["text", "number", "boolean", "array", "object", "function", "element", "color", "dimension", "resource", "meta", "events"].includes(n) || (t[n] = e[n]);
    }), t;
  }
  // Получение компонента из реестра
  getComponentFromRegistry(e) {
    return m.getComponent(e);
  }
}
const H = new ye();
class we {
  createElement(e, t, n) {
    return {
      type: e,
      props: t,
      children: n
    };
  }
  render(e, t) {
    console.log("[SvelteRenderer] Rendering component:", e);
  }
  unmount(e) {
    console.log("[SvelteRenderer] Unmounting component from container:", e);
  }
}
class be {
  constructor() {
    a(this, "id", "svelte");
    a(this, "meta", {
      name: "Svelte Adapter",
      version: "1.0.0",
      platform: "svelte"
    });
    a(this, "renderer", new we());
    // Компоненты, которые поддерживает этот адаптер
    a(this, "supportedComponents", [
      "button",
      "text",
      "input",
      "card",
      "modal",
      "form",
      "list",
      "table",
      "tabs",
      "accordion",
      "slider",
      "progress",
      "checkbox",
      "radio",
      "select",
      "textarea",
      "image",
      "link",
      "container",
      "layout",
      "media",
      "panel",
      "side",
      "footer",
      "filter",
      "feed",
      "code",
      "cardcart",
      "article"
    ]);
  }
  // Рендеринг компонента
  render(e) {
    const { component: t, ...n } = e, r = this.getComponentFromRegistry(t);
    if (!r)
      throw new v(t);
    const s = this.adaptProps(n);
    return this.renderer.createElement(r, s, []);
  }
  // Проверка совместимости компонента
  isCompatible(e) {
    return !!(e && (e.$$render || e.fragment));
  }
  // Получение поддерживаемых компонентов
  getSupportedComponents() {
    return this.supportedComponents;
  }
  // Валидация спецификации
  validateSpec(e) {
    if (!e.component || typeof e.component != "string" || !m.getComponent(e.component))
      return !1;
    const n = m.getComponentSchema(e.component);
    if (n) {
      const r = n.props.filter((s) => s.required);
      for (const s of r)
        if (e[s.name] === void 0)
          return !1;
    }
    return !0;
  }
  // Адаптация пропсов для Svelte
  adaptProps(e) {
    const t = {};
    return e.text !== void 0 && (t.text = e.text), e.number !== void 0 && (t.number = e.number), e.boolean !== void 0 && (t.boolean = e.boolean), e.array !== void 0 && (t.array = e.array), e.object !== void 0 && (t.object = e.object), e.function !== void 0 && (t.function = e.function), e.element !== void 0 && (t.element = e.element), e.color !== void 0 && (t.color = e.color), e.dimension !== void 0 && (t.dimension = e.dimension), e.resource !== void 0 && (t.resource = e.resource), e.meta && (e.meta.className && (t.class = e.meta.className), e.meta.style && (t.style = e.meta.style), e.meta.theme && (t.theme = e.meta.theme)), e.events && Object.keys(e.events).forEach((n) => {
      t[`on:${n}`] = e.events[n];
    }), Object.keys(e).forEach((n) => {
      ["text", "number", "boolean", "array", "object", "function", "element", "color", "dimension", "resource", "meta", "events"].includes(n) || (t[n] = e[n]);
    }), t;
  }
  // Получение компонента из реестра
  getComponentFromRegistry(e) {
    return m.getComponent(e);
  }
}
const I = new be();
class ve {
  createElement(e, t, n) {
    return {
      type: e,
      props: t,
      children: n
    };
  }
  render(e, t) {
    console.log("[VanillaRenderer] Rendering component:", e);
  }
  unmount(e) {
    console.log("[VanillaRenderer] Unmounting component from container:", e);
  }
}
class Ce {
  constructor() {
    a(this, "id", "vanilla");
    a(this, "meta", {
      name: "Vanilla JS Adapter",
      version: "1.0.0",
      platform: "vanilla"
    });
    a(this, "renderer", new ve());
    // Компоненты, которые поддерживает этот адаптер
    a(this, "supportedComponents", [
      "button",
      "text",
      "input",
      "card",
      "modal",
      "form",
      "list",
      "table",
      "tabs",
      "accordion",
      "slider",
      "progress",
      "checkbox",
      "radio",
      "select",
      "textarea",
      "image",
      "link",
      "container",
      "layout",
      "media",
      "panel",
      "side",
      "footer",
      "filter",
      "feed",
      "code",
      "cardcart",
      "article"
    ]);
  }
  // Рендеринг компонента
  render(e) {
    const { component: t, ...n } = e, r = this.getComponentFromRegistry(t);
    if (!r)
      throw new v(t);
    const s = this.adaptProps(n);
    return this.renderer.createElement(r, s, []);
  }
  // Проверка совместимости компонента
  isCompatible(e) {
    return !!(e && (typeof e == "function" || typeof e == "object"));
  }
  // Получение поддерживаемых компонентов
  getSupportedComponents() {
    return this.supportedComponents;
  }
  // Валидация спецификации
  validateSpec(e) {
    if (!e.component || typeof e.component != "string" || !m.getComponent(e.component))
      return !1;
    const n = m.getComponentSchema(e.component);
    if (n) {
      const r = n.props.filter((s) => s.required);
      for (const s of r)
        if (e[s.name] === void 0)
          return !1;
    }
    return !0;
  }
  // Адаптация пропсов для Vanilla JS
  adaptProps(e) {
    const t = {};
    return e.text !== void 0 && (t.text = e.text), e.number !== void 0 && (t.number = e.number), e.boolean !== void 0 && (t.boolean = e.boolean), e.array !== void 0 && (t.array = e.array), e.object !== void 0 && (t.object = e.object), e.function !== void 0 && (t.function = e.function), e.element !== void 0 && (t.element = e.element), e.color !== void 0 && (t.color = e.color), e.dimension !== void 0 && (t.dimension = e.dimension), e.resource !== void 0 && (t.resource = e.resource), e.meta && (e.meta.className && (t.className = e.meta.className), e.meta.style && (t.style = e.meta.style), e.meta.theme && (t.theme = e.meta.theme)), e.events && Object.keys(e.events).forEach((n) => {
      t[n] = e.events[n];
    }), Object.keys(e).forEach((n) => {
      ["text", "number", "boolean", "array", "object", "function", "element", "color", "dimension", "resource", "meta", "events"].includes(n) || (t[n] = e[n]);
    }), t;
  }
  // Получение компонента из реестра
  getComponentFromRegistry(e) {
    return m.getComponent(e);
  }
}
const q = new Ce();
class Se {
  constructor() {
    a(this, "responses", /* @__PURE__ */ new Map());
  }
  setResponse(e, t) {
    this.responses.set(e, t);
  }
  async fetch(e) {
    const t = this.responses.get(e) || { error: "Not found" };
    return {
      ok: !t.error,
      json: () => Promise.resolve(t),
      status: t.error ? 404 : 200,
      statusText: t.error ? "Not Found" : "OK"
    };
  }
}
class Re {
  constructor() {
    a(this, "mockAPI");
    a(this, "testResults", []);
    this.mockAPI = new Se(), this.setupMockFetch();
  }
  setupMockFetch() {
    global.fetch = (e) => this.mockAPI.fetch(e);
  }
  async runAllTests() {
    c.info("🚀 Starting Data Layer Tests..."), await this.runTest("DataSource Registration", () => this.testDataSourceRegistration()), await this.runTest("Data Fetching", () => this.testDataFetching()), await this.runTest("Caching", () => this.testCaching()), await this.runTest("Subscriptions", () => this.testSubscriptions()), await this.runTest("Error Handling", () => this.testErrorHandling()), await this.runTest("Data Transformation", () => this.testDataTransformation()), await this.runTest("Reactive Updates", () => this.testReactiveUpdates()), await this.runTest("UserFace Integration", () => this.testUserFaceIntegration()), this.printResults();
  }
  async runTest(e, t) {
    const n = Date.now();
    let r = !1, s;
    try {
      await t(), r = !0;
    } catch (l) {
      s = l instanceof Error ? l.message : String(l);
    }
    const i = Date.now() - n;
    this.testResults.push({ name: e, passed: r, error: s, duration: i });
  }
  async testDataSourceRegistration() {
    if (d.registerDataSource("/api/test", { type: "api", url: "https://api.example.com/test" }), !d.getState("/api/test"))
      throw new Error("Data source state not created");
  }
  async testDataFetching() {
    d.registerDataSource("/api/users/1", { type: "api", url: "https://api.example.com/api/users/1" }), this.mockAPI.setResponse("https://api.example.com/api/users/1", { id: 1, name: "John" });
    const e = await d.getData("/api/users/1");
    if (!e || e.id !== 1)
      throw new Error("Data fetching failed");
  }
  async testCaching() {
    d.clearAllData(), d.registerDataSource("/api/cache-test", {
      type: "api",
      url: "https://api.example.com/cache-test",
      cache: !0
    }), this.mockAPI.setResponse("https://api.example.com/cache-test", { cached: !0 });
    const e = Date.now();
    await d.getData("/api/cache-test");
    const t = Date.now() - e, n = Date.now();
    await d.getData("/api/cache-test");
    const r = Date.now() - n;
    if (r >= t)
      throw new Error(`Cache not working: first call ${t}ms, second call ${r}ms`);
  }
  async testSubscriptions() {
    let e = null;
    const t = d.subscribe("/api/sub-test", (n) => {
      e = n;
    });
    if (d.registerDataSource("/api/sub-test", { type: "api", url: "https://api.example.com/sub-test" }), this.mockAPI.setResponse("https://api.example.com/sub-test", { subscribed: !0 }), await d.getData("/api/sub-test"), !e || !e.subscribed)
      throw new Error("Subscription not working");
    d.unsubscribe(t.id);
  }
  async testErrorHandling() {
    d.registerDataSource("/api/error", { type: "api", url: "https://api.example.com/error" }), this.mockAPI.setResponse("https://api.example.com/error", { error: "Server Error" });
    try {
      throw await d.getData("/api/error"), new Error("Should have thrown an error");
    } catch {
    }
  }
  async testDataTransformation() {
    if (d.registerDataSource("/api/transform", {
      type: "api",
      url: "https://api.example.com/transform",
      transform: (t) => ({ ...t, transformed: !0 })
    }), this.mockAPI.setResponse("https://api.example.com/transform", { original: !0 }), !(await d.getData("/api/transform")).transformed)
      throw new Error("Data transformation failed");
  }
  async testReactiveUpdates() {
    let e = 0;
    if (d.subscribe("/api/reactive", () => {
      e++;
    }), d.registerDataSource("/api/reactive", { type: "api", url: "https://api.example.com/reactive" }), this.mockAPI.setResponse("https://api.example.com/reactive", { reactive: !0 }), await d.getData("/api/reactive"), e === 0)
      throw new Error("Reactive updates not working");
  }
  async testUserFaceIntegration() {
    if (!{
      data: {}
    }.data)
      throw new Error("UserFace data property missing");
  }
  printResults() {
    c.info(`
🎯 DATA LAYER TEST RESULTS:`), c.info("============================================================");
    let e = 0, t = 0, n = 0;
    for (const r of this.testResults) {
      const s = r.passed ? "✅" : "❌", i = `${r.duration}ms`;
      c.info(`${s} ${r.name} (${i})`), r.passed ? e++ : (t++, r.error && c.info(`   Error: ${r.error}`)), n += r.duration;
    }
    c.info("============================================================"), c.info(`📊 Results: ${e} passed, ${t} failed (${n}ms total)`), c.info("🎉 Data Layer tests completed!");
  }
}
async function Le() {
  await new Re().runAllTests();
}
class Ee {
  // Анализ компонента любой платформы
  analyzeComponent(e, t) {
    return j.isValidElement(e) || e.$$typeof ? this.analyzeReactComponent(e, t) : e.render || e.template || e.setup ? this.analyzeVueComponent(e, t) : e.selector || e.templateUrl || e.template ? this.analyzeAngularComponent(e, t) : e.$$render || e.fragment ? this.analyzeSvelteComponent(e, t) : this.analyzeVanillaComponent(e, t);
  }
  analyzeReactComponent(e, t) {
    const n = [];
    return e.propTypes && Object.keys(e.propTypes).forEach((r) => {
      const s = e.propTypes[r];
      n.push({
        name: r,
        type: this.mapReactPropType(s),
        required: s.isRequired || !1,
        description: `React prop: ${r}`
      });
    }), e.defaultProps && Object.keys(e.defaultProps).forEach((r) => {
      const s = n.find((i) => i.name === r);
      s ? s.defaultValue = e.defaultProps[r] : n.push({
        name: r,
        type: "text",
        required: !1,
        defaultValue: e.defaultProps[r],
        description: `React default prop: ${r}`
      });
    }), {
      name: t,
      platform: "react",
      props: n,
      events: [
        { name: "onClick", parameters: [], description: "Click event" },
        { name: "onChange", parameters: ["value"], description: "Change event" }
      ],
      children: !0,
      description: `React component ${t}`
    };
  }
  analyzeVueComponent(e, t) {
    const n = [];
    return e.props && Object.keys(e.props).forEach((r) => {
      const s = e.props[r];
      let i = "text", l = !1;
      typeof s == "object" ? (i = this.mapVuePropType(s.type), l = s.required || !1) : i = this.mapVuePropType(s), n.push({
        name: r,
        type: i,
        required: l,
        description: `Vue prop: ${r}`
      });
    }), {
      name: t,
      platform: "vue",
      props: n,
      events: [
        { name: "click", parameters: [], description: "Click event" },
        { name: "change", parameters: ["value"], description: "Change event" }
      ],
      children: !0,
      description: `Vue component ${t}`
    };
  }
  analyzeAngularComponent(e, t) {
    const n = [];
    try {
      typeof Reflect < "u" && Reflect.getMetadata && (Reflect.getMetadata("inputs", e) || []).forEach((s) => {
        n.push({
          name: s.propertyName || s,
          type: "text",
          required: !1,
          description: `Angular input: ${s.propertyName || s}`
        });
      });
    } catch (r) {
      c.debug("Angular metadata not available", "Analyzer", r);
    }
    return {
      name: t,
      platform: "angular",
      props: n,
      events: [
        { name: "click", parameters: [], description: "Click event" },
        { name: "change", parameters: ["value"], description: "Change event" }
      ],
      children: !0,
      description: `Angular component ${t}`
    };
  }
  analyzeSvelteComponent(e, t) {
    const n = [];
    if (e.$$render) {
      const s = e.$$render.toString().match(/\$(\w+)/g);
      s && s.forEach((i) => {
        const l = i.substring(1);
        n.push({
          name: l,
          type: "text",
          required: !1,
          description: `Svelte prop: ${l}`
        });
      });
    }
    return {
      name: t,
      platform: "svelte",
      props: n,
      events: [
        { name: "click", parameters: [], description: "Click event" },
        { name: "change", parameters: ["value"], description: "Change event" }
      ],
      children: !0,
      description: `Svelte component ${t}`
    };
  }
  analyzeVanillaComponent(e, t) {
    const n = [];
    if (typeof e == "function") {
      const s = e.toString().match(/\(([^)]*)\)/);
      s && s[1] && s[1].split(",").map((l) => l.trim()).filter((l) => l).forEach((l) => {
        n.push({
          name: l,
          type: "text",
          required: !1,
          description: `Vanilla prop: ${l}`
        });
      });
    }
    return {
      name: t,
      platform: "vanilla",
      props: n,
      events: [
        { name: "click", parameters: [], description: "Click event" },
        { name: "change", parameters: ["value"], description: "Change event" }
      ],
      children: !0,
      description: `Vanilla JS component ${t}`
    };
  }
  // Маппинг типов для разных платформ
  mapReactPropType(e) {
    const t = j.PropTypes;
    return t && e === t.string ? "text" : t && e === t.number ? "number" : t && e === t.bool ? "boolean" : t && e === t.array ? "array" : t && e === t.object ? "object" : t && e === t.func ? "function" : t && e === t.element ? "element" : "text";
  }
  mapVuePropType(e) {
    return e === String ? "text" : e === Number ? "number" : e === Boolean ? "boolean" : e === Array ? "array" : e === Object ? "object" : e === Function ? "function" : "text";
  }
}
const E = new Ee();
class $e {
  constructor() {
    // === ОСНОВНЫЕ КОМПОНЕНТЫ ===
    a(this, "components", /* @__PURE__ */ new Map());
    a(this, "schemas", /* @__PURE__ */ new Map());
    a(this, "adapters", /* @__PURE__ */ new Map());
    // Убираем дублирование
    // Хеши для валидации
    a(this, "componentHashes", /* @__PURE__ */ new Map());
    a(this, "schemaHashes", /* @__PURE__ */ new Map());
    // Статистика
    a(this, "stats", {
      totalComponents: 0,
      totalSchemas: 0,
      totalAdapters: 0,
      lastUpdate: Date.now()
    });
    // === ИНТЕГРАЦИЯ С ДРУГИМИ СЕРВИСАМИ ===
    a(this, "validationEngine");
    a(this, "errorRecovery");
    a(this, "dataLayer");
    a(this, "pluginSystem");
    a(this, "testingInfrastructure");
    c.info("Registry initialized", "Registry"), this.validationEngine = $, this.errorRecovery = V, this.dataLayer = d, this.pluginSystem = ae(this), this.testingInfrastructure = K;
  }
  // === РЕГИСТРАЦИЯ ===
  registerComponent(e, t) {
    const n = Date.now();
    try {
      const r = E.analyzeComponent(t, e);
      return this.components.set(e, t), this.schemas.set(e, r), this.stats.totalComponents++, this.stats.lastUpdate = Date.now(), this.componentHashes.set(e, this.computeHash(t)), this.schemaHashes.set(e, this.computeHash(r)), c.info(`Component registered: ${e}`, "Registry", {
        name: e,
        schema: r.name,
        duration: Date.now() - n
      }), r;
    } catch (r) {
      throw c.error(`Failed to register component: ${e}`, "Registry", { name: e, error: r }), r;
    }
  }
  getComponent(e) {
    return this.components.get(e);
  }
  getSchema(e) {
    return this.schemas.get(e);
  }
  getAllComponents() {
    return Object.fromEntries(this.components);
  }
  getAllComponentNames() {
    return Array.from(this.components.keys());
  }
  getAllSchemas() {
    return Array.from(this.schemas.values());
  }
  getSchemasByPlatform(e) {
    return Array.from(this.schemas.values()).filter((t) => t.platform === e);
  }
  // === РЕНДЕРЕРЫ ПЛАТФОРМ ===
  registerAdapter(e) {
    const t = e.id || `adapter-${this.adapters.size}`;
    this.adapters.set(t, e), this.stats.totalAdapters++, c.info(`Adapter registered: ${t}`, "Registry");
  }
  reinstallAdapter(e) {
    const t = e.id || `adapter-${this.adapters.size}`;
    this.adapters.set(t, e), c.info(`Adapter reinstalled: ${t}`, "Registry");
  }
  getAdapter(e) {
    return this.adapters.get(e);
  }
  getAllAdapters() {
    return Array.from(this.adapters.values());
  }
  // === РЕНДЕРИНГ ===
  renderWithAdapter(e, t) {
    const n = this.getAdapter(t);
    if (!n)
      throw new Error(`Adapter not found: ${t}`);
    return n.render(e);
  }
  renderWithAllAdapters(e) {
    const t = {};
    for (const [n, r] of this.adapters)
      try {
        t[n] = r.render(e);
      } catch (s) {
        c.error(`Render failed for adapter: ${n}`, "Registry", { adapterId: n, error: s }), t[n] = { error: s.message };
      }
    return t;
  }
  // === ЖИЗНЕННЫЙ ЦИКЛ ===
  updateComponent(e, t) {
    if (!this.components.has(e))
      return c.warn(`Cannot update non-existent component "${e}"`, "Registry", { name: e }), null;
    this.schemas.get(e);
    const n = E.analyzeComponent(t, e);
    return this.components.set(e, t), this.schemas.set(e, n), c.info(`Component updated: ${e}`, "Registry", { name: e }), n;
  }
  removeComponent(e) {
    const t = this.components.delete(e);
    return t && (this.schemas.delete(e), this.componentHashes.delete(e), this.schemaHashes.delete(e), this.stats.totalComponents--, c.info(`Component removed: ${e}`, "Registry", { name: e })), t;
  }
  clearCache() {
    this.componentHashes.clear(), this.schemaHashes.clear(), c.info("Cache cleared", "Registry");
  }
  clear() {
    const e = this.components.size;
    this.components.clear(), this.schemas.clear(), this.componentHashes.clear(), this.schemaHashes.clear(), this.stats.totalComponents = 0, this.stats.totalSchemas = 0, c.info(`Registry cleared, removed ${e} components`, "Registry");
  }
  // === СТАТИСТИКА ===
  getStats() {
    return {
      ...this.stats,
      adapters: this.adapters.size,
      hashes: {
        components: this.componentHashes.size,
        schemas: this.schemaHashes.size
      }
    };
  }
  // === API ДЛЯ КОНВЕРТЕРА ===
  exportSchema(e) {
    const t = this.schemas.get(e);
    return t ? { ...t } : (c.warn(`Schema not found for export: ${e}`, "Registry", { name: e }), null);
  }
  exportAllSchemas() {
    return Array.from(this.schemas.values()).map((e) => ({ ...e }));
  }
  validateMigration(e, t) {
    const n = Array.from(this.adapters.values()).find((r) => r.id === t);
    return n ? { valid: !0, adapter: n } : { valid: !1, error: `Target platform not found: ${t}` };
  }
  // === ПЛАГИНЫ ===
  async registerPlugin(e, t) {
    await this.pluginSystem.registerPlugin(e, t);
  }
  async uninstallPlugin(e) {
    await this.pluginSystem.uninstallPlugin(e);
  }
  getActivePlugins() {
    return this.pluginSystem.getActivePlugins();
  }
  getPlugin(e) {
    return this.pluginSystem.getPlugin(e);
  }
  getAllPlugins() {
    return this.pluginSystem.getAllPlugins();
  }
  // === ВАЛИДАЦИЯ ===
  validateComponent(e) {
    const t = this.components.get(e), n = this.schemas.get(e);
    return !t || !n ? !1 : this.validationEngine.validateComponent(t, n).isValid;
  }
  validateUserFace(e) {
    const t = this.schemas.get(e.component);
    return t ? this.validationEngine.validateUserFace(e, t).isValid : !1;
  }
  // === ТЕСТИРОВАНИЕ ===
  async runAllTests() {
    return this.testingInfrastructure.runAllTests();
  }
  createMockComponent(e, t, n) {
    return this.testingInfrastructure.createMockComponent(e, t, n);
  }
  generateTestData(e) {
    return this.testingInfrastructure.generateTestData(e);
  }
  // === DATA LAYER ===
  async getData(e, t) {
    return this.dataLayer.getData(e, t);
  }
  registerDataSource(e, t) {
    this.dataLayer.registerDataSource(e, t);
  }
  subscribeToData(e, t) {
    return this.dataLayer.subscribe(e, t);
  }
  getDataState(e) {
    return this.dataLayer.getState(e);
  }
  // === РЕНДЕРИНГ С ДАННЫМИ ===
  async render(e, t) {
    try {
      if (!this.validateUserFace(e))
        throw new Error(`Invalid UserFace: ${e.component}`);
      return await this.renderWithData(e, t);
    } catch (n) {
      throw c.error(`Render failed: ${n.message}`, "Registry", { userFace: e, adapterId: t, error: n }), n;
    }
  }
  async renderWithData(e, t) {
    if (e.data)
      for (const [n, r] of Object.entries(e.data)) {
        const s = await this.dataLayer.getData(r.source, r.config);
        e[n] = s;
      }
    return this.renderWithAdapter(e, t);
  }
  // === ПРИВАТНЫЕ МЕТОДЫ ===
  computeHash(e) {
    return JSON.stringify(e).split("").reduce((t, n) => (t = (t << 5) - t + n.charCodeAt(0), t & t), 0).toString();
  }
  analyzeComponent(e, t) {
    return E.analyzeComponent(e, t);
  }
  createFallbackSchema(e) {
    return {
      name: e,
      platform: "universal",
      props: [],
      events: []
    };
  }
}
const Ae = {
  displayName: "TestButton",
  propTypes: {
    text: { type: "string", required: !0 },
    onClick: { type: "function", required: !1 }
  }
}, ke = {
  name: "TestVueButton",
  props: {
    text: { type: String, required: !0 },
    onClick: { type: Function, required: !1 }
  }
};
class Pe {
  constructor() {
    a(this, "registry");
    a(this, "testResults", []);
    this.registry = new $e();
  }
  async runAllTests() {
    c.info("🚀 Starting Comprehensive Engine Tests..."), await this.runTestSuite("Registry", () => this.testRegistry()), await this.runTestSuite("Validation", () => this.testValidation()), await this.runTestSuite("Error Recovery", () => this.testErrorRecovery()), await this.runTestSuite("Plugin System", () => this.testPluginSystem()), await this.runTestSuite("Analyzer", () => this.testAnalyzer()), await this.runTestSuite("Integration", () => this.testIntegration()), this.printResults();
  }
  async runTestSuite(e, t) {
    c.info(`📋 Running test suite: ${e}`);
    const n = Date.now();
    let r = !1, s;
    try {
      await t(), r = !0;
    } catch (l) {
      s = l instanceof Error ? l.message : String(l);
    }
    const i = Date.now() - n;
    this.testResults.push({ name: e, passed: r, error: s, duration: i }), c.info(`✅ ${e} completed ${r ? "successfully" : "with errors"}`);
  }
  async testRegistry() {
    const e = {
      name: "TestButton",
      platform: "react",
      props: [
        { name: "text", type: "text", required: !0 },
        { name: "onClick", type: "function", required: !1 }
      ],
      events: [
        { name: "click", description: "Button click event" },
        { name: "hover", description: "Button hover event" }
      ],
      children: !0,
      description: "React component TestButton"
    };
    this.registry.registerComponent("TestButton", e);
    const t = this.registry.getComponent("TestButton");
    if (!t || t.name !== "TestButton")
      throw new Error("Component registration failed");
  }
  async testValidation() {
    const e = {
      name: "TestComponent",
      platform: "react",
      props: [
        { name: "text", type: "text", required: !0 },
        { name: "count", type: "number", required: !1 }
      ],
      events: [
        { name: "click", description: "Click event" }
      ],
      children: !1,
      description: "Test component"
    }, t = {
      component: "TestComponent",
      text: "Hello World",
      count: 42,
      events: {
        click: () => console.log("clicked")
      }
    };
    if (!$.validateUserFace(t, e).isValid)
      throw new Error("Valid UserFace failed validation");
    const r = {
      component: "TestComponent",
      count: "not a number"
    };
    if ($.validateUserFace(r, e).isValid)
      throw new Error("Invalid UserFace passed validation");
  }
  async testErrorRecovery() {
    const e = {
      component: "NonExistentComponent",
      text: "This will fail"
    };
    try {
      throw this.registry.renderWithAdapter(e, "react"), new Error("Should have thrown an error");
    } catch (t) {
      const n = V.handleComponentError(
        t,
        e,
        { strategy: "fallback" }
      );
      if (!n || n.component !== "div")
        throw new Error("Error recovery failed");
    }
  }
  async testPluginSystem() {
    const e = {
      id: "test-plugin",
      name: "Test Plugin",
      version: "1.0.0",
      type: "custom",
      description: "Test plugin for testing",
      install: async () => console.log("Plugin installed"),
      uninstall: async () => console.log("Plugin uninstalled"),
      enable: async () => console.log("Plugin enabled"),
      disable: async () => console.log("Plugin disabled")
    };
    if (await f.registerPlugin(e), await f.installPlugin("test-plugin"), await f.enablePlugin("test-plugin"), await f.disablePlugin("test-plugin"), await f.uninstallPlugin("test-plugin"), await f.removePlugin("test-plugin"), f.getAllPlugins().length !== 0)
      throw new Error("Plugin cleanup failed");
  }
  async testAnalyzer() {
    const e = E.analyzeComponent(Ae, "TestButton");
    if (!e || e.platform !== "react")
      throw new Error("React component analysis failed");
    const t = E.analyzeComponent(ke, "TestVueButton");
    if (!t || t.platform !== "vue")
      throw new Error("Vue component analysis failed");
  }
  async testIntegration() {
    const e = {
      name: "TestButton",
      platform: "react",
      props: [
        { name: "text", type: "text", required: !0 },
        { name: "user", type: "object", required: !1 }
      ],
      events: [
        { name: "click", description: "Button click" }
      ],
      children: !1,
      description: "Test button with data"
    };
    this.registry.registerComponent("TestButton", e), d.registerDataSource("/api/test", {
      type: "api",
      url: "https://api.example.com/test",
      cache: !0
    });
    const t = {
      component: "TestButton",
      text: "Click me",
      data: {
        user: {
          source: "/api/test",
          config: {
            cache: !0,
            transform: (n) => ({ ...n, processed: !0 })
          }
        }
      }
    };
    try {
      await this.registry.renderWithAdapter(t, "react");
    } catch (n) {
      const r = n instanceof Error ? n.message : String(n);
      if (!r.includes("Adapter not found") && !r.includes("fetch failed"))
        throw n;
    }
  }
  printResults() {
    c.info(`
🎯 COMPREHENSIVE ENGINE TEST RESULTS:`), c.info("============================================================");
    let e = 0, t = 0, n = 0;
    for (const r of this.testResults) {
      const s = r.passed ? "✅" : "❌", i = `${r.duration}ms`;
      c.info(`${s} ${r.name} (${i})`), r.passed ? e++ : (t++, r.error && c.info(`   Error: ${r.error}`)), n += r.duration;
    }
    c.info("============================================================"), c.info(`📊 Results: ${e} passed, ${t} failed (${n}ms total)`), c.info("🎉 Comprehensive tests completed!"), c.info("📊 Engine is fully tested and ready for production!");
  }
}
async function ze() {
  await new Pe().runAllTests();
}
function Oe(o) {
  return typeof o == "object" && o !== null && typeof o.component == "string" && o.component.length > 0;
}
const xe = [
  {
    id: "react-adapter",
    name: "React Adapter",
    version: "1.0.0",
    type: "adapter",
    adapter: z,
    install: () => {
      m.registerAdapter(z);
    }
  },
  {
    id: "vue-adapter",
    name: "Vue Adapter",
    version: "1.0.0",
    type: "adapter",
    adapter: O,
    install: () => {
      m.registerAdapter(O);
    }
  },
  {
    id: "angular-adapter",
    name: "Angular Adapter",
    version: "1.0.0",
    type: "adapter",
    adapter: H,
    install: () => {
      m.registerAdapter(H);
    }
  },
  {
    id: "svelte-adapter",
    name: "Svelte Adapter",
    version: "1.0.0",
    type: "adapter",
    adapter: I,
    install: () => {
      m.registerAdapter(I);
    }
  },
  {
    id: "vanilla-adapter",
    name: "Vanilla JS Adapter",
    version: "1.0.0",
    type: "adapter",
    adapter: q,
    install: () => {
      m.registerAdapter(q);
    }
  }
];
async function De() {
  for (const o of xe)
    await m.registerPlugin(o), await m.installPlugin(o.id);
}
De().catch(console.error);
export {
  v as ComponentNotFoundError,
  B as DataLayer,
  k as Engine,
  ie as EngineFactory,
  _ as ErrorRecovery,
  le as NodeEngine,
  T as PluginSystem,
  Fe as ReactContextProvider,
  ye as RenderAngular,
  Me as RenderError,
  he as RenderReact,
  be as RenderSvelte,
  Ce as RenderVanilla,
  fe as RenderVue,
  J as TestingInfrastructure,
  M as UserFaceError,
  je as UserRenderer,
  W as ValidationEngine,
  L as ValidationError,
  d as dataLayer,
  m as engine,
  V as errorRecovery,
  R as events,
  g as lifecycle,
  c as logger,
  Ve as nodeEngine,
  f as pluginSystem,
  H as renderAngular,
  z as renderReact,
  I as renderSvelte,
  q as renderVanilla,
  O as renderVue,
  ze as runComprehensiveTests,
  Le as runDataLayerTests,
  K as testingInfrastructure,
  me as useUserContext,
  Ue as useUserFace,
  Oe as validateUserFace,
  $ as validationEngine
};
